This document uses axitxt compression: standard abbreviations, txtspeak shortcuts, emoji symbols for concepts, and omitted articles/pronouns where context is clear.

# Create âœ¨ - Axiomantic âœ¨ Dev

Plan & impl âœ¨ following Axiomantic principles: **$ARGUMENTS**

## âœ¨ Dev Fwk

### Phase 1: Analysis & Planning
1. **Req Analysis**
   - What exactly needs 2 be built?
   - Who r stakeholders & users?
   - What r acceptance criteria?
   - What r constraints & assumptions?

2. **Arch Assessment**
   - How does this âœ¨ fit into existing codebase?
   - What existing patterns & conventions shld be followed?
   - What comp need 2 be created or modified?
   - R there any arch impacts or considerations?

3. **Risk Analysis**
   - What cld go wrong during impl?
   - What r potenti breaking changes?
   - How will this affect existing functionality?
   - What r rollback strategies?

### Phase 2: Design & Arch
1. **Tech Design**
   - What's overall approach & arch?
   - Which design patterns r most appropr8?
   - How will data flow thru sys?
   - What r key iface & contracts?

2. **Impl Strategy**
   - What ğŸ“ need 2 be created or modified?
   - What's sequence dev steps?
   - How can âœ¨ be dev'd incrementally?
   - What r key milestones & checkpoints?

### Phase 3: Impl Plan
1. **Dev Steps**
   - Step-by-step impl plan
   - Dependencies btwn different parts
   - Testable milestones 4 incremental delivery
   - Integration points w/ existing code

2. **ğŸ§ª Strategy**
   - Unit ğŸ§ª approach & coverage targets
   - Integration ğŸ§ª req
   - End-2-end ğŸ§ª scenarios
   - âš¡ ğŸ§ª considerations

### Phase 4: Four-Pillar Valid8n
Plan valid8n vs each Axiomantic pillar:

1. **Coding Stds** - Style guide compliance, code quality ğŸ“Š
2. **Docs** - API docs, user guidel, arch docs
3. **Proj Patterns** - Consistency w/ existing codebase patterns
4. **ğŸ§ª** - Comprehensive ğŸ§ª coverage w/ meaningful assertions

## ğŸš¨ Assessment Questions

B4 starting impl, address:

- **Is this âœ¨ rly needed?** Cld existing functionality be extended instead?
- **Have we considered all edge cases?** What happens when things go wrong?
- **Is design scalable?** How will it perform under load?
- **Does it follow existing patterns?** Or does it introduce unnecessary complexity?
- **Can it be tested effectively?** Is design testable & maintainable?
- **What's maintenance burden?** How much ongoing effort will this require?

## Professional Dialogue

**Push back constructively** if:
- Req r unclear or incomplete
- Proposed approach seems problematic
- There r better alternatives 2 consider
- âœ¨ introduces unnecessary complexity
- ğŸ§ª strategy is insufficient

**Ur ğŸ¯**: Deliver âœ¨ that exemplifies Axiomantic principles precision, elegance, robustness & wisdom.

## Output Format

1. **âœ¨ Analysis**: Req, constraints & stakeholder needs
2. **Arch Impact**: How it fits into existing sys
3. **Impl Roadmap**: Detailed step-by-step plan
4. **Risk Assessment**: What cld go wrong & mitigation strategies
5. **Valid8n Plan**: How 2 ensure Axiomantic stds r met

Remember: Better 2 spend time planning well than 2 impl poorly & refactor l8r.