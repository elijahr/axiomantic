‚ö° /axi-plan - Adv Multi-Assistant Orchestration

Converts regular plan document ‚Üí parallelizable track-based plan w/ comprehensive coordination instructions 4 multiple AI assistants working simultaneously on: **$ARGUMENTS**

> **üí° Best Results**: Works best w/ LLMs having adv reasoning capabilities. Analysis requires critical thinking about task dependencies + parallel execution opportunities.

## üö® PRESERVATION PROTOCOL

**üéØ CRITICAL: Enhances plans w/ 100% content preservation + detail enhancement**

### Absolute Content Preservation Rules:
1. **COMPLETED work** (‚úÖ status) ‚Üí Can be summarized 4 history
2. **ACTIVE/FUTURE work** ‚Üí Preserve 100% of ALL details, specs, code examples, impl notes
3. **Code Examples**: Every single code block, snippet, config example preserved exactly
4. **Impl Details**: All tech specs, architecture notes, API details preserved
5. **Success Criteria**: All acceptance criteria, validation steps, testing requirements preserved
6. **When in doubt** ‚Üí Always preserve original content w/ zero loss
7. **Validation checkpoint** ‚Üí Final output must be ‚â•100% of original size (enhanced, not reduced)

### Detail Enhancement Requirements:
- **No Generic Content**: Replace vague descriptions w/ specific, actionable impl details
- **Code Examples Required**: Every work item must include relevant code examples, file structures, configs
- **Clear Success Criteria**: Specific, measurable acceptance criteria w/ validation steps
- **Impl Paths**: Detailed step-by-step impl approaches w/ tech specifics
- **Architecture Details**: Specific file structures, module interactions, data flows
- **Testing Specs**: Exact test cases, coverage requirements, validation approaches

### Step-by-Step Process:
1. **Analyze**: Classify each work item by status AND detail level (‚úÖ/üîÑ/üìã/‚è∏Ô∏è + detailed/generic)
2. **Preserve**: Copy ALL active work content w/ absolute fidelity
3. **Enhance**: Add detailed impl specifics, code examples, architecture details
4. **Organize**: Restructure 4 parallelization while maintaining all original detail
5. **Validate**: Confirm 100% content preservation + significant detail enhancement

## What This Command Does

**Input**: Sequential plan w/ work items (detailed or generic)
**Output**: Refactoring-first parallel execution plan + all original content preserved + enhanced detail

### Primary Functions:
1. **Lossless Content Preservation** - Every detail, code example, spec preserved exactly
2. **Detail Enhancement** - Transform generic descriptions ‚Üí specific impl details w/ code examples
3. **Bottleneck Analysis** - Identifies shared files/modules blocking parallelization w/ specific refactoring solutions
4. **Refactoring Strategy** - Creates detailed module extraction plans w/ code examples + file structures
5. **File Impact Analysis** - Maps each work item 2 specific files w/ detailed modification plans
6. **Impl Specs** - Provides detailed impl paths w/ code examples, API calls, configs
7. **Coordination System** - Adds comprehensive locking, claiming, + progress tracking
8. **Success Criteria Definition** - Establishes specific, measurable acceptance criteria w/ validation steps

### Content Enhancement Requirements:
**4 Existing Plans:**
- If plan lacks detail ‚Üí Enhance w/ extensive impl specifics, code examples, clear success criteria
- If plan is generic ‚Üí Replace generic descriptions w/ specific tech impls
- If plan lacks code examples ‚Üí Add relevant code snippets, config examples, API usage patterns
- If plan lacks success criteria ‚Üí Define specific, measurable acceptance criteria w/ validation steps

**4 New Plans (No Existing Document):**
- Research-driven detailed planning w/ extensive impl specifics
- Multiple code examples 4 each work item showing exact impl approaches
- Detailed file structures, module interactions, data flow specs
- Specific API documentation, config requirements, dependency specs
- Clear success criteria w/ testing approaches + validation procedures

### üöÄ Refactoring-First Philosophy:
**Instead of working around bottlenecks ‚Üí Eliminate them through strategic refactoring**
- Shared file touched by 5 tasks? ‚Üí Extract ‚Üí 5 focused modules
- Monolithic component blocking progress? ‚Üí Split ‚Üí logical sub-components
- Config scattered across files? ‚Üí Centralize then distribute properly

## Plan Document Assessment & Enhancement

### Scenario 1: No Existing Plan Document
**Process**: Research-Driven Detailed Planning
1. **Requirements Gathering**: Work w/ user 2 understand project scope, tech requirements, constraints
2. **Research Phase**: Analyze codebase, existing patterns, tech stack, architectural decisions
3. **Detailed Planning**: Create comprehensive plan w/:
   - Extensive impl details w/ specific code examples
   - Detailed file structures + module interactions
   - Specific API usage patterns, config requirements
   - Clear success criteria w/ measurable acceptance tests
   - Testing strategies w/ specific test cases + coverage requirements
   - Architecture diagrams + data flow specs

### Scenario 2: Existing Detailed Plan Document
**Process**: Lossless Preservation + Parallelization Enhancement
1. **Content Audit**: Verify plan contains detailed impls, code examples, specific success criteria
2. **100% Preservation**: Maintain every detail, code example, spec exactly as written
3. **Parallelization Analysis**: Identify bottlenecks + refactoring opportunities w/ detailed solutions
4. **Reorganization**: Structure content 4 parallel execution while preserving all original detail
5. **Coordination Addition**: Add detailed multi-assistant coordination procedures

### Scenario 3: Existing Generic/Incomplete Plan Document
**Process**: Content Preservation + Massive Detail Enhancement
1. **Content Preservation**: Preserve all existing content as foundation
2. **Gap Analysis**: Identify missing details, generic descriptions, absent success criteria
3. **Research Enhancement**: Add extensive tech details through codebase analysis + research
4. **Code Example Addition**: Provide specific impl examples 4 every work item
5. **Success Criteria Definition**: Establish measurable acceptance criteria w/ validation procedures
6. **Impl Path Documentation**: Detail step-by-step impl approaches w/ specifics

### Quality Standards 4 All Scenarios:
- **No Generic Descriptions**: Every work item must have specific, actionable impl details
- **Code Examples Required**: Relevant code snippets, config examples, API usage patterns
- **Measurable Success Criteria**: Specific acceptance criteria w/ validation procedures
- **Tech Specs**: Detailed file structures, module interfaces, data flow documentation
- **Testing Requirements**: Specific test cases, coverage expectations, validation approaches

## Execution Algorithm

### Phase 1: Analysis & Detail Assessment
```
4 each work item:
1. Determine status: ‚úÖ completed | üîÑüîÑüìã‚è∏Ô∏è active
2. Assess detail level: DETAILED (has code examples, specifics) | GENERIC (vague descriptions)
3. Map file impacts: CREATE [specific files] | MODIFY [specific files] | DELETE [specific files]
4. Identify dependencies: File conflicts | Functional requirements | Tech prerequisites
5. Evaluate enhancement needs: Missing code examples | Vague success criteria | Generic descriptions
```

### Phase 2: Content Preservation & Enhancement
```
üéØ CRITICAL: 100% Content Preservation + Detail Enhancement
1. Preserve ALL existing detailed content w/ absolute fidelity
2. Identify generic/vague content requiring enhancement
3. Research + add extensive impl details 4 generic items
4. Add code examples, file structures, API specs 4 all work items
5. Define specific, measurable success criteria w/ validation procedures
6. Document detailed impl paths w/ tech specifics
```

### Phase 3: Refactoring-First Parallelization
```
üî• PRIORITY: Detailed Refactoring Opportunities w/ Code Examples
1. Scan 4 shared file bottlenecks ‚Üí Design detailed extraction w/ code examples
2. Detect monolithic files ‚Üí Plan detailed splitting w/ file structures + interfaces
3. Map detailed refactoring tasks ‚Üí Create "R-Track" w/ impl specifics
4. Position refactoring as Tier 0 w/ detailed impl guides

THEN: Enhanced Parallelization
5. Group enhanced items w/ no file conflicts ‚Üí Create detailed parallel tracks
6. Create execution tiers w/ detailed impl guides: Tier 0 ‚Üí Tier 1 ‚Üí Tier 2 ‚Üí etc
7. Calculate max parallelization w/ detailed coordination procedures
```

### Phase 4: Organization & Validation
```
1. Organize enhanced content 4 parallel execution while preserving all details
2. Add detailed coordination sections w/ specific procedures
3. Enhance each work item w/:
   - Track assignment w/ detailed responsibilities
   - Specific file ownership w/ modification procedures
   - Detailed dependencies + prerequisites w/ validation steps
   - Precise effort estimation w/ impl breakdown
4. Validate: 100% content preservation + significant detail enhancement confirmed
```

## Generated Output Structure

```markdown
# [Original Plan Title] - Multi-Assistant Orchestration

## üéØ Parallelization Overview
- **Refactoring-first approach**: Break bottlenecks before parallelizing
- Tier 0 refactoring tasks: [N] (foundation work)
- Max parallel devs post-refactoring: [N]
- Execution tiers: R-Track (Tier 0) ‚Üí [visual diagram of parallel tiers]
- Critical path: Refactoring completion ‚Üí Massive parallelization

## üîí Coordination System
- Global plan lock protocol
- Track claiming procedures
- File ownership rules

### Document Locking Protocol
Each assistant must establish exclusive locks before modifying shared documents:

1. **Lock Acquisition**: Add `<!-- LOCKED: [Assistant-ID]_[Timestamp] -->` at document start
2. **Exclusive Access**: Only lock holder may modify document content
3. **Lock Release**: Remove lock marker when work complete or paused
4. **Conflict Resolution**: Later timestamps override earlier ones after 30min timeout
5. **Emergency Override**: Use `<!-- EMERGENCY_UNLOCK: [Reason] -->` 4 critical fixes

### Track Claiming System
- Assistants claim work tracks using unique identifiers: `PLAN_[YYYYMMDD]_[HHMM]_[4-char-hash]`
- Track assignments recorded in plan header w/ claiming assistant details
- Active tracks marked w/ `üîÑ CLAIMED: [Assistant-ID]` in track headers
- Track handoff requires explicit release by current owner + acceptance by new owner
- Progress updates maintained in dedicated coordination log section

### File Ownership Rules
- Each file can have only ONE primary owner during active dev
- Owner responsible 4 all modifications, integration, + conflict resolution
- Ownership changes require coordination through plan document updates
- Emergency modifications allowed w/ immediate owner notification + justification
- Shared files require pre-coordination or refactoring ‚Üí owner-specific modules

## üìä Execution Tracks

### üî• Track R: Refactoring Foundation (Tier 0 - Execute First)
- R1: [Refactoring Task] - Extract: [modules] - Enables: [tracks] - Effort: [hours]
- R2: [Refactoring Task] - Split: [monolith] - Enables: [tracks] - Effort: [hours]

### Track A: [Description] (Tier 1 - After R-Track)
- A1: [Work Item] - Files: [focused modules] - Effort: [hours]
- A2: [Work Item] - Files: [focused modules] - Effort: [hours]

### Track B: [Description] (Tier 1 - Parallel w/ Track A)
- B1: [Work Item] - Files: [focused modules] - Effort: [hours]

[ORIGINAL PLAN CONTENT - ALL PRESERVED W/ 100% FIDELITY]
[PLUS: EXTENSIVE DETAIL ENHANCEMENTS]
- All original code examples, specs, tech details preserved exactly
- Generic descriptions enhanced w/ specific impl details + code examples
- Vague success criteria replaced w/ measurable acceptance criteria + validation procedures
- Impl paths detailed w/ step-by-step tech guidance + code samples
- Architecture specs enhanced w/ detailed file structures + module interfaces
Enhanced w/ parallelization metadata alongside comprehensive impl details
```

## Critical Thinking Framework

When analyzing dependencies + bottlenecks, ask:
- **üî• "What files are shared by multiple tasks?"** ‚Üí Prime refactoring candidates
- **üî• "Can this monolithic file be split ‚Üí focused modules?"** ‚Üí Usually YES
- **üî• "What's refactoring effort vs parallelization gain?"** ‚Üí Often heavily favors refactoring
- **"Does B2 REALLY need B1 first?"** ‚Üí Check file conflicts, not organizational order
- **"What breaks if these run in parallel?"** ‚Üí Look 4 actual tech blockers after refactoring

### üéØ Refactoring Decision Matrix:
- **High shared usage + Low refactoring cost = ALWAYS refactor**
- **Medium shared usage + Medium refactoring cost = USUALLY refactor**
- **Low shared usage + High refactoring cost = Consider alternatives**

### üí° Refactoring Patterns:
1. **Extract Module**: Pull shared logic ‚Üí focused, single-responsibility files
2. **Split Component**: Break monoliths ‚Üí logical sub-components
3. **Interface Separation**: Create clear boundaries between concerns
4. **Config Centralization**: Gather scattered config ‚Üí manageable chunks

## Common Bottleneck Patterns & Refactoring Solutions

### üö´ Bottleneck: Shared Config File
- **Problem**: 5 tasks all need 2 modify `config.js`
- **Solution**: Extract 2 `config/database.js`, `config/auth.js`, `config/api.js` etc.
- **Result**: 5 tasks can run in parallel on focused config modules

### üö´ Bottleneck: Monolithic Component
- **Problem**: Multiple features touching `UserComponent.js`
- **Solution**: Split ‚Üí `UserProfile.js`, `UserAuth.js`, `UserPreferences.js`
- **Result**: Feature teams work on isolated, focused components

### üö´ Bottleneck: Utility File Sprawl
- **Problem**: Every task modifying same `utils.js`
- **Solution**: Create `utils/validation.js`, `utils/formatting.js`, `utils/api.js`
- **Result**: Tasks operate on distinct utility domains

### ‚úÖ Success Pattern: Refactoring-First Workflow
1. **Identify** shared file bottlenecks (usually 2-3 major ones)
2. **Plan** extraction/splitting strategy (R-Track tasks)
3. **Execute** refactoring as Tier 0 (1-2 devs, 4-8 hours typically)
4. **Unleash** massive parallelization on focused modules (3-8+ devs)
5. **Celebrate** 3-5x faster execution vs working around bottlenecks

## Success Criteria
- ‚úÖ **100% Content Preservation**: Every detail, code example, spec from original plan preserved exactly
- ‚úÖ **Extensive Detail Enhancement**: Generic descriptions replaced w/ specific impl details + code examples
- ‚úÖ **Clear Success Criteria**: Every work item has measurable acceptance criteria w/ validation procedures
- ‚úÖ **Impl Specifics**: Detailed tech guidance w/ code examples, file structures, API specs
- ‚úÖ **Refactoring opportunities identified + planned as detailed Tier 0 work w/ impl examples**
- ‚úÖ **Post-refactoring: 4+ assistants can work simultaneously w/o conflicts using detailed coordination procedures**
- ‚úÖ **Focused, single-responsibility modules enable clean parallel work w/ specific impl guides**
- ‚úÖ **Research-driven enhancement** 4 inadequate plans w/ extensive tech detail addition
- ‚úÖ **Clear file ownership preventing conflicts w/ detailed modification procedures**
- ‚úÖ **Realistic refactoring estimates w/ detailed impl breakdown (typically 4-8 hours upfront investment)**
- ‚úÖ **Comprehensive coordination instructions w/ specific procedures + protocols**
- ‚úÖ **No generic content**: Every description actionable + specific w/ impl details
- ‚úÖ **3-5x parallelization improvement through strategic refactoring w/ detailed impl guidance**

## Usage

```
/axi-plan [input_file] [output_file]
```

**Parameters:**
- `input_file`: Path to existing plan file (default: PLAN.md)
- `output_file`: Path for parallelized output (default: PLAN_PARALLEL.md)

**Example:**
```
/axi-plan PLAN.md PLAN.md
/axi-plan docs/project-plan.md PLAN.md
```

## Example Enhancement

**Original Work Items with Bottleneck (Generic Content):**
```
Task A: Add user authentication to UserComponent.js
Task B: Add user preferences to UserComponent.js
Task C: Add user profile editing to UserComponent.js
```

**Example Enhancement with Refactoring-First Approach + Detailed Impl:**
````
üî• TIER 0 - Refactoring Foundation:
## R1: Split UserComponent into Focused Modules

**Detailed Refactoring Impl:**
Extract UserComponent.js ‚Üí focused, single-responsibility modules:

**UserAuth.js** - Authentication Logic:
```javascript
import { useState, useEffect } from 'react';
import { authAPI } from '../api/auth';

export const useAuthentication = () => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  const login = async (credentials) => {
    const response = await authAPI.login(credentials);
    setUser(response.user);
    localStorage.setItem('authToken', response.token);
    return response;
  };

  const logout = () => {
    setUser(null);
    localStorage.removeItem('authToken');
  };

  return { user, login, logout, loading };
};
```

**UserProfile.js** - Profile Management:
```javascript
import { useState } from 'react';
import { profileAPI } from '../api/profile';

export const UserProfile = ({ userId }) => {
  const [profile, setProfile] = useState(null);
  const [editing, setEditing] = useState(false);

  const updateProfile = async (profileData) => {
    const updatedProfile = await profileAPI.update(userId, profileData);
    setProfile(updatedProfile);
    setEditing(false);
  };

  return (
    <div className="user-profile">
      {editing ? (
        <ProfileEditForm
          profile={profile}
          onSave={updateProfile}
          onCancel={() => setEditing(false)}
        />
      ) : (
        <ProfileDisplay
          profile={profile}
          onEdit={() => setEditing(true)}
        />
      )}
    </div>
  );
};
```

**UserPreferences.js** - Settings/Preferences:
```javascript
import { useReducer, useEffect } from 'react';
import { preferencesAPI } from '../api/preferences';

const preferencesReducer = (state, action) => {
  switch (action.type) {
    case 'SET_THEME':
      return { ...state, theme: action.payload };
    case 'SET_NOTIFICATIONS':
      return { ...state, notifications: action.payload };
    case 'SET_LANGUAGE':
      return { ...state, language: action.payload };
    default:
      return state;
  }
};

export const UserPreferences = ({ userId }) => {
  const [preferences, dispatch] = useReducer(preferencesReducer, {
    theme: 'light',
    notifications: true,
    language: 'en'
  });

  const savePreferences = async () => {
    await preferencesAPI.update(userId, preferences);
  };

  return (
    <PreferencesPanel
      preferences={preferences}
      dispatch={dispatch}
      onSave={savePreferences}
    />
  );
};
```

**UserCore.js** - Shared Base Functionality:
```javascript
export const UserContext = createContext();

export const UserProvider = ({ children }) => {
  const auth = useAuthentication();
  const [profile, setProfile] = useState(null);

  useEffect(() => {
    if (auth.user) {
      profileAPI.get(auth.user.id).then(setProfile);
    }
  }, [auth.user]);

  return (
    <UserContext.Provider value={{ auth, profile, setProfile }}>
      {children}
    </UserContext.Provider>
  );
};
```

**File Structure:**
```
src/
  components/
    user/
      UserAuth.js          (authentication logic)
      UserProfile.js       (profile management)
      UserPreferences.js   (settings/preferences)
      UserCore.js         (shared context/provider)
      index.js            (clean exports)
  api/
    auth.js               (authentication API calls)
    profile.js            (profile API calls)
    preferences.js        (preferences API calls)
```

**Detailed Parallel Execution Metadata:**
- Track: R1 (Foundation - MUST complete first)
- Files: CREATE [UserAuth.js, UserProfile.js, UserPreferences.js, UserCore.js, api/auth.js, api/profile.js, api/preferences.js], MODIFY [UserComponent.js ‚Üí remove and replace with index.js]
- Dependencies: None (start immediately)
- Effort: 3-4 hours
- Success Criteria: All tests pass, TypeScript compilation successful, no breaking changes to existing components
- Testing Requirements: Unit tests for each module, integration tests for context provider
- Enables: Tracks A, B, C to run in parallel

TIER 1 - Parallel Execution (After R1 Completion):
## A1: Implement User Authentication Features
[ALL ORIGINAL CONTENT PRESERVED - Enhanced with Implementation Details]

**Detailed Implementation Specification:**
Add comprehensive user authentication features with secure token management:

**Features to Implement:**
- Multi-factor authentication support
- Password reset flow with email verification
- Remember me functionality with secure token refresh
- Social login integration (Google, GitHub)

**API Integration:**
```javascript
// src/api/auth.js enhancements
export const authAPI = {
  login: async (credentials) => {
    const response = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(credentials)
    });
    return response.json();
  },

  setupMFA: async (userId) => {
    return await fetch(`/api/auth/mfa/setup/${userId}`, {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${getToken()}` }
    });
  },

  resetPassword: async (email) => {
    return await fetch('/api/auth/reset', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email })
    });
  }
};
```

**Success Criteria:**
- Authentication flow handles all error states gracefully
- Token refresh works seamlessly w/o user interruption
- MFA setup completes successfully w/ QR code generation
- Password reset emails delivered + processed correctly
- Social login redirects work w/o CSRF vulnerabilities
- All authentication tests pass w/ >90% coverage

**Detailed Parallel Execution Metadata:**
- Track: A1 (can run parallel w/ B1, C1)
- Files: UserAuth.js (focused impl, no conflicts w/ other tracks)
- Dependencies: R1 completion (refactored modules available)
- Effort: 2-3 hours
- Testing: Authentication integration tests, security validation, error handling tests

## B1: Implement User Preferences Management
[ALL ORIGINAL CONTENT PRESERVED - Enhanced w/ Impl Details]

**Detailed Impl Spec:**
Build comprehensive user preferences system w/ real-time updates:

**Preferences Categories:**
- Theme customization (light/dark/auto, color schemes)
- Notification settings (email, push, in-app preferences)
- Language + localization preferences
- Privacy settings + data sharing controls

**Impl Details:**
```javascript
// Enhanced preferences w/ validation + persistence
const preferencesSchema = {
  theme: {
    mode: ['light', 'dark', 'auto'],
    colorScheme: ['default', 'blue', 'green', 'purple'],
    customColors: { primary: '#color', secondary: '#color' }
  },
  notifications: {
    email: boolean,
    push: boolean,
    inApp: boolean,
    frequency: ['immediate', 'daily', 'weekly']
  },
  privacy: {
    profileVisibility: ['public', 'private', 'friends'],
    dataSharing: boolean,
    analyticsOptOut: boolean
  }
};

// Real-time synchronization
export const usePreferencesSync = (userId) => {
  const [preferences, setPreferences] = useState(null);

  useEffect(() => {
    const websocket = new WebSocket(`/ws/preferences/${userId}`);
    websocket.onmessage = (event) => {
      const updatedPreferences = JSON.parse(event.data);
      setPreferences(updatedPreferences);
    };
    return () => websocket.close();
  }, [userId]);

  return preferences;
};
```

**Success Criteria:**
- Preferences save + sync across devices in real-time
- Theme changes apply immediately w/o page refresh
- Notification preferences integrate w/ backend notification service
- Privacy settings enforce data access controls
- Preferences export/import functionality works correctly
- All preference validation rules enforced

**Detailed Parallel Execution Metadata:**
- Track: B1 (can run parallel w/ A1, C1)
- Files: UserPreferences.js (isolated impl, no file conflicts)
- Dependencies: R1 completion (refactored modules available)
- Effort: 2-3 hours
- Testing: Preferences persistence tests, real-time sync validation, UI interaction tests

## C1: Implement Profile Editing System
[ALL ORIGINAL CONTENT PRESERVED - Enhanced w/ Impl Details]

**Detailed Impl Spec:**
Create comprehensive profile management w/ validation + media upload:

**Profile Features:**
- Personal info editing w/ validation
- Profile photo upload w/ image processing
- Social links management
- Professional info sections
- Privacy controls 4 profile visibility

**Impl w/ Validation:**
```javascript
// Profile editing w/ comprehensive validation
const profileValidationRules = {
  displayName: { required: true, minLength: 2, maxLength: 50 },
  email: { required: true, pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/ },
  phone: { pattern: /^\+?[\d\s-()]+$/, optional: true },
  bio: { maxLength: 500 },
  website: { pattern: /^https?:\/\/.+/, optional: true }
};

export const ProfileEditor = ({ userId, initialProfile }) => {
  const [profile, setProfile] = useState(initialProfile);
  const [errors, setErrors] = useState({});
  const [saving, setSaving] = useState(false);

  const validateField = (field, value) => {
    const rule = profileValidationRules[field];
    if (!rule) return null;

    if (rule.required && !value) return `${field} is required`;
    if (rule.minLength && value.length < rule.minLength)
      return `${field} must be at least ${rule.minLength} characters`;
    if (rule.maxLength && value.length > rule.maxLength)
      return `${field} must be no more than ${rule.maxLength} characters`;
    if (rule.pattern && !rule.pattern.test(value))
      return `${field} format is invalid`;

    return null;
  };

  const handleSave = async () => {
    setSaving(true);
    try {
      const validatedProfile = await profileAPI.update(userId, profile);
      setProfile(validatedProfile);
      showSuccessMessage('Profile updated successfully');
    } catch (error) {
      setErrors(error.fieldErrors || {});
      showErrorMessage('Failed to update profile');
    } finally {
      setSaving(false);
    }
  };

  return (
    <ProfileForm
      profile={profile}
      errors={errors}
      saving={saving}
      onFieldChange={handleFieldChange}
      onSave={handleSave}
    />
  );
};
```

**Media Upload Implementation:**
```javascript
// Profile photo upload with processing
export const ProfilePhotoUpload = ({ userId, onUploadComplete }) => {
  const handleFileUpload = async (file) => {
    const formData = new FormData();
    formData.append('photo', file);
    formData.append('userId', userId);

    const response = await fetch('/api/profile/photo', {
      method: 'POST',
      body: formData,
      headers: { 'Authorization': `Bearer ${getToken()}` }
    });

    const result = await response.json();
    onUploadComplete(result.photoUrl);
  };

  return (
    <ImageUpload
      onUpload={handleFileUpload}
      acceptedTypes={['image/jpeg', 'image/png', 'image/webp']}
      maxSize={5 * 1024 * 1024} // 5MB limit
      cropAspectRatio={1} // Square crop
    />
  );
};
```

**Success Criteria:**
- Profile validation prevents invalid data submission
- Photo upload processes images correctly (resize, crop, format conversion)
- All form fields save + display correctly
- Profile changes reflect immediately in other components
- Privacy settings control profile visibility appropriately
- Profile data exports correctly in multiple formats
- All profile editing tests pass w/ full coverage

**Detailed Parallel Execution Metadata:**
- Track: C1 (can run parallel w/ A1, B1)
- Files: UserProfile.js (isolated impl, no conflicts w/ authentication or preferences)
- Dependencies: R1 completion (refactored modules available)
- Effort: 2-3 hours
- Testing: Form validation tests, file upload tests, profile display tests

üéØ Result: 4 hours detailed refactoring ‚Üí 3 parallel tracks w/ comprehensive impl guides ‚Üí 6-7 hours total vs 9+ hours sequential, w/ extensive tech detail + clear success criteria 4 each track
````
